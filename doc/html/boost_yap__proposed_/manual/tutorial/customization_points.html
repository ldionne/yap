<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Customization Points</title>
<link rel="stylesheet" href="../../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../../../index.html" title="Chapter&#160;1.&#160;Boost.YAP (Proposed)">
<link rel="up" href="../tutorial.html" title="Tutorial">
<link rel="prev" href="how_expression_operands_are_treated.html" title="How Expression Operands Are Treated">
<link rel="next" href="transform_matching.html" title="Transform Matching">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="how_expression_operands_are_treated.html"><img src="../../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../../images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../images/home.png" alt="Home"></a><a accesskey="n" href="transform_matching.html"><img src="../../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_yap__proposed_.manual.tutorial.customization_points"></a><a class="link" href="customization_points.html" title="Customization Points">Customization
        Points</a>
</h4></div></div></div>
<p>
          There are a number of customization points defined by Boost.YAP that are
          used during expression evaluation. Boost.YAP customization points are patterned
          after the ones in the <a href="https://github.com/ericniebler/range-v3" target="_top">Range-v3</a>
          library, the basis for the ISO Ranges TS. To override one, you create a
          function with the same name in your own namespace; it gets picked up via
          ADL. By creating your own version of one of these customization points,
          you can change how expressions are evaluated in <code class="computeroutput"><a class="link" href="../../../boost/yap/transform.html" title="Function template transform">evaluate()</a></code>
          and <code class="computeroutput"><a class="link" href="../../../boost/yap/transform.html" title="Function template transform">evaluate_as()</a></code>.
        </p>
<p>
          For example: first we define a UDT <code class="computeroutput"><span class="identifier">number</span></code>
          and an override of Boost.YAP's <code class="computeroutput"><span class="identifier">eval_plus</span></code>
          for it,
        </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">user</span> <span class="special">{</span>

    <span class="keyword">struct</span> <span class="identifier">number</span>
    <span class="special">{</span>
        <span class="keyword">double</span> <span class="identifier">value</span><span class="special">;</span>
    <span class="special">};</span>

    <span class="identifier">number</span> <span class="identifier">eval_plus</span> <span class="special">(</span><span class="identifier">number</span> <span class="identifier">lhs</span><span class="special">,</span> <span class="identifier">number</span> <span class="identifier">rhs</span><span class="special">)</span>
    <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">number</span><span class="special">{</span><span class="identifier">lhs</span><span class="special">.</span><span class="identifier">value</span> <span class="special">+</span> <span class="identifier">rhs</span><span class="special">.</span><span class="identifier">value</span><span class="special">};</span> <span class="special">}</span>

<span class="special">}</span>
</pre>
<p>
        </p>
<p>
          then we use it to evaluate expressions containing <code class="computeroutput"><span class="identifier">number</span></code>s,
          even though there is no user-defined plus operator for <code class="computeroutput"><span class="identifier">number</span></code>:
        </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">plus_expr</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">make_terminal</span><span class="special">(</span><span class="identifier">user</span><span class="special">::</span><span class="identifier">number</span><span class="special">{</span><span class="number">2.0</span><span class="special">})</span> <span class="special">+</span> <span class="identifier">user</span><span class="special">::</span><span class="identifier">number</span><span class="special">{</span><span class="number">1.0</span><span class="special">};</span>
<span class="keyword">auto</span> <span class="identifier">minus_expr</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">make_terminal</span><span class="special">(</span><span class="identifier">user</span><span class="special">::</span><span class="identifier">number</span><span class="special">{</span><span class="number">2.0</span><span class="special">})</span> <span class="special">-</span> <span class="identifier">user</span><span class="special">::</span><span class="identifier">number</span><span class="special">{</span><span class="number">1.0</span><span class="special">};</span>

<span class="identifier">user</span><span class="special">::</span><span class="identifier">number</span> <span class="identifier">plus_result</span> <span class="special">=</span> <span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">plus_expr</span><span class="special">);</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">plus_result</span><span class="special">.</span><span class="identifier">value</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span> <span class="comment">// Prints 1.</span>

<span class="comment">// Does not compile; there is no operator- defined over user::number.</span>
<span class="comment">//user::number minus_result = evaluate(minus_expr);</span>
</pre>
<p>
        </p>
<p>
          There is a customization point for each operator (including <code class="computeroutput"><span class="identifier">if_else</span></code>), one for doing implicit transforms
          during evaluation, called <code class="computeroutput"><span class="identifier">transform_expression</span><span class="special">()</span></code>, and yet one more for replacing the entire
          implementation of <code class="computeroutput"><a class="link" href="../../../boost/yap/transform.html" title="Function template transform">evaluate_as()</a></code>,
          called <code class="computeroutput"><span class="identifier">eval_expression_as</span><span class="special">()</span></code>. The complete list of the customization
          points can be found in the <code class="computeroutput"><span class="identifier">function_objects</span></code>
          namespace in the <code class="computeroutput"><a class="link" href="../../../header/boost/yap/operators_hpp.html" title="Header &lt;boost/yap/operators.hpp&gt;">operators header</a></code>.
        </p>
<p>
          You just saw an example of an operator customization point above. Here's
          an example overriding the <code class="computeroutput"><span class="identifier">transform_expression</span><span class="special">()</span></code> customization point:
        </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// A convenient alias; nothing to see here.</span>
<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">using</span> <span class="identifier">term</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">terminal</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">expression</span><span class="special">,</span> <span class="identifier">T</span><span class="special">&gt;;</span>

<span class="keyword">namespace</span> <span class="identifier">user</span> <span class="special">{</span>

    <span class="keyword">auto</span> <span class="identifier">transform_expression</span> <span class="special">(</span><span class="keyword">decltype</span><span class="special">(</span><span class="identifier">term</span><span class="special">&lt;</span><span class="identifier">number</span><span class="special">&gt;{{</span><span class="number">0.0</span><span class="special">}}</span> <span class="special">*</span> <span class="identifier">number</span><span class="special">{})</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span><span class="special">)</span>
    <span class="special">{</span> <span class="keyword">return</span> <span class="string">"Yay."</span><span class="special">;</span> <span class="special">}</span>

<span class="special">}</span>
</pre>
<p>
        </p>
<p>
          and using it:
        </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">expr</span> <span class="special">=</span> <span class="identifier">term</span><span class="special">&lt;</span><span class="identifier">user</span><span class="special">::</span><span class="identifier">number</span><span class="special">&gt;{{</span><span class="number">1.0e6</span><span class="special">}}</span> <span class="special">*</span> <span class="identifier">user</span><span class="special">::</span><span class="identifier">number</span><span class="special">{</span><span class="number">1.0e6</span><span class="special">};</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span> <span class="comment">// Prints "Yay."  Wierd!</span>
</pre>
<p>
        </p>
<p>
          The <code class="computeroutput"><span class="identifier">eval_expression_as</span><span class="special">()</span></code> customization point works similarly.
        </p>
<p>
          You can create as many overloads of a customization point <code class="computeroutput"><span class="identifier">C</span></code> as you like. If there are 100 overloads
          of <code class="computeroutput"><span class="identifier">C</span></code>, any of them that
          match subexpressions within the expression being evaluated will be used;
          you only need to make sure that the overloads are mutually unambiguous.
        </p>
<p>
          This feature is especially useful when it comes to the <code class="computeroutput"><span class="identifier">transform_expression</span><span class="special">()</span></code> customization point. Providing multiple
          overloads can be very useful for defining an implicit set of transformations
          that you always want applied to all your expression evaluations. For example,
          if you define a template overload and a nontemplate overload for a certain
          customization point <code class="computeroutput"><span class="identifier">C</span></code>,
          the template will only apply when the nontemplate does not (due to the
          normal C++ overload resolution rules); this allows general-casing in the
          template overload, and special-casing in the nontemplate overload.
        </p>
<h6>
<a name="boost_yap__proposed_.manual.tutorial.customization_points.h0"></a>
          <span class="phrase"><a name="boost_yap__proposed_.manual.tutorial.customization_points.how_the_transform_expression_customization_point_is_applied"></a></span><a class="link" href="customization_points.html#boost_yap__proposed_.manual.tutorial.customization_points.how_the_transform_expression_customization_point_is_applied">How
          the transform_expression Customization Point Is Applied</a>
        </h6>
<p>
          If at any point during the execution of <code class="computeroutput"><a class="link" href="../../../boost/yap/transform.html" title="Function template transform">evaluate()</a></code>
          or <code class="computeroutput"><a class="link" href="../../../boost/yap/transform.html" title="Function template transform">evaluate_as()</a></code>, if <code class="computeroutput"><span class="identifier">expr</span></code>
          is the current subexpression and <code class="computeroutput"><span class="identifier">transform_expression</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)</span></code> is well-formed, <code class="computeroutput"><span class="identifier">transform_expression</span><span class="special">(</span><span class="identifier">expr</span><span class="special">)</span></code> gets called in place of the normal evaluation
          of <code class="computeroutput"><span class="identifier">expr</span></code>.
        </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../../../images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top"><p>
            Subexpressions of <code class="computeroutput"><span class="identifier">expr</span></code>
            are not evaluated recursively, and in fact they are not evaluated at
            all! The arguments passed to <code class="computeroutput"><span class="identifier">transform_expression</span><span class="special">()</span></code> are <a class="link" href="../../concepts.html#boost_yap__proposed_.concepts.expression">Expressions</a>,
            not evaluated values.
          </p></td></tr>
</table></div>
<p>
          If you want recursive evaluation within your <code class="computeroutput"><span class="identifier">transform_expression</span><span class="special">()</span></code> override, just use <code class="computeroutput"><span class="identifier">evaluate</span><span class="special">()</span></code> directly:
        </p>
<p>
          This transform takes expressions of the form <code class="computeroutput"><span class="identifier">a</span>
          <span class="special">*</span> <span class="identifier">x</span>
          <span class="special">+</span> <span class="identifier">y</span></code>
          and calls a function that does that computation in one step:
        </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Expr1</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Expr2</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Expr3</span><span class="special">&gt;</span>
<span class="keyword">decltype</span><span class="special">(</span><span class="keyword">auto</span><span class="special">)</span> <span class="identifier">transform_expression</span> <span class="special">(</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">expression</span><span class="special">&lt;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">expr_kind</span><span class="special">::</span><span class="identifier">plus</span><span class="special">,</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hana</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">expression</span><span class="special">&lt;</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">yap</span><span class="special">::</span><span class="identifier">expr_kind</span><span class="special">::</span><span class="identifier">multiplies</span><span class="special">,</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">hana</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span>
                    <span class="identifier">Expr1</span><span class="special">,</span>
                    <span class="identifier">Expr2</span>
                <span class="special">&gt;</span>
            <span class="special">&gt;,</span>
            <span class="identifier">Expr3</span>
        <span class="special">&gt;</span>
    <span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">expr</span>
<span class="special">)</span> <span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">naxpy</span><span class="special">(</span>
        <span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">expr</span><span class="special">.</span><span class="identifier">left</span><span class="special">().</span><span class="identifier">left</span><span class="special">()),</span>
        <span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">expr</span><span class="special">.</span><span class="identifier">left</span><span class="special">().</span><span class="identifier">right</span><span class="special">()),</span>
        <span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">expr</span><span class="special">.</span><span class="identifier">right</span><span class="special">())</span>
    <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        </p>
<p>
          and since <code class="computeroutput"><span class="identifier">evaluate</span><span class="special">()</span></code>
          is called on each operand in the transform, the transform is applied to
          each parenthesized subexpression here, and then to the top-level expression:
        </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">auto</span> <span class="identifier">expr</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">a</span> <span class="special">*</span> <span class="identifier">x</span> <span class="special">+</span> <span class="identifier">y</span><span class="special">)</span> <span class="special">*</span> <span class="special">(</span><span class="identifier">a</span> <span class="special">*</span> <span class="identifier">x</span> <span class="special">+</span> <span class="identifier">y</span><span class="special">)</span> <span class="special">+</span> <span class="special">(</span><span class="identifier">a</span> <span class="special">*</span> <span class="identifier">x</span> <span class="special">+</span> <span class="identifier">y</span><span class="special">);</span>

<span class="identifier">user</span><span class="special">::</span><span class="identifier">number</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">expr</span><span class="special">;</span>
</pre>
<p>
        </p>
<h6>
<a name="boost_yap__proposed_.manual.tutorial.customization_points.h1"></a>
          <span class="phrase"><a name="boost_yap__proposed_.manual.tutorial.customization_points.how_the_eval_expression_as_customization_point_is_applied"></a></span><a class="link" href="customization_points.html#boost_yap__proposed_.manual.tutorial.customization_points.how_the_eval_expression_as_customization_point_is_applied">How
          the eval_expression_as Customization Point Is Applied</a>
        </h6>
<p>
          The <code class="computeroutput"><span class="identifier">eval_expression_as</span><span class="special">()</span></code> customization point is only applied at
          the top level, replacing a call to Boost.YAP's version. Like <code class="computeroutput"><span class="identifier">transform_expression</span><span class="special">()</span></code>,
          it subverts the normal recursive evaluation of the expression being evaluated.
          Also like <code class="computeroutput"><span class="identifier">transform_expression</span><span class="special">()</span></code>, it is passed an <a class="link" href="../../concepts.html#boost_yap__proposed_.concepts.expression">Expression</a>.
        </p>
<p>
          <code class="computeroutput"><span class="identifier">eval_expression_as</span><span class="special">()</span></code>
          may be useful if you want to evaluate an expression in a very different
          way depending on what the desired result type is.
        </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
            Evaluation of <code class="computeroutput"><a class="link" href="../../../boost/yap/expression.html" title="Struct template expression">expression&lt;&gt;</a></code>'s optional conversion
            operator template is done via <code class="computeroutput"><span class="identifier">eval_expression_as</span><span class="special">()</span></code>. See <code class="computeroutput"><a class="link" href="../../../BOOST_YAP_CONVERSION_OPERATOR_TEMPLATE.html" title="Macro BOOST_YAP_CONVERSION_OPERATOR_TEMPLATE">BOOST_YAP_CONVERSION_OPERATOR_TEMPLATE</a></code>
            for details.
          </p></td></tr>
</table></div>
<h6>
<a name="boost_yap__proposed_.manual.tutorial.customization_points.h2"></a>
          <span class="phrase"><a name="boost_yap__proposed_.manual.tutorial.customization_points.how_the_other_customization_points_are_applied"></a></span><a class="link" href="customization_points.html#boost_yap__proposed_.manual.tutorial.customization_points.how_the_other_customization_points_are_applied">How
          The Other Customization Points Are Applied</a>
        </h6>
<p>
          Each of <code class="computeroutput"><a class="link" href="../../../boost/yap/transform.html" title="Function template transform">evaluate()</a></code> and <code class="computeroutput"><a class="link" href="../../../boost/yap/transform.html" title="Function template transform">evaluate_as()</a></code>
          evaluates its given expression recursively, depth first (unless of course
          the <code class="computeroutput"><span class="identifier">transform_expression</span><span class="special">()</span></code> customization point subverts this). For
          any given subexpression <code class="computeroutput"><span class="identifier">E</span></code>
          of kind <code class="computeroutput"><span class="identifier">K</span></code> with subexpressions
          <code class="computeroutput"><span class="identifier">S0</span></code> ... <code class="computeroutput"><span class="identifier">Sn</span></code>,
          <code class="computeroutput"><span class="identifier">E</span></code> is evaluated as:
        </p>
<pre class="programlisting"><span class="identifier">eval_K</span><span class="special">(</span><span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">S0</span><span class="special">),</span> <span class="special">...</span> <span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">Sn</span><span class="special">))</span>
</pre>
<p>
          For example, using <code class="computeroutput"><span class="identifier">expr_kind</span><span class="special">::</span><span class="identifier">plus</span></code>:
        </p>
<pre class="programlisting"><span class="identifier">eval_plus</span><span class="special">(</span><span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">left</span><span class="special">(</span><span class="identifier">e</span><span class="special">)),</span> <span class="identifier">evaluate</span><span class="special">(</span><span class="identifier">right</span><span class="special">(</span><span class="identifier">e</span><span class="special">)))</span>
</pre>
<p>
          This means that a (sufficiently general) templated <code class="computeroutput"><span class="identifier">eval_plus</span><span class="special">()</span></code> customization point override would apply
          to all plus operations in an expression tree, even nested ones.
        </p>
<p>
          All the customization points except <code class="computeroutput"><span class="identifier">transform_expression</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">eval_expression_as</span><span class="special">()</span></code> receive evaluated values in their arguments,
          not <a class="link" href="../../concepts.html#boost_yap__proposed_.concepts.expression">Expressions</a>.
          That is, unless some of the evaluated values happen to be <a class="link" href="../../concepts.html#boost_yap__proposed_.concepts.expression">Expressions</a>
          -- you may have written an expression that evaluates to an expression.
          You may also be a weirdo.
        </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="how_expression_operands_are_treated.html"><img src="../../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../../images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../images/home.png" alt="Home"></a><a accesskey="n" href="transform_matching.html"><img src="../../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
